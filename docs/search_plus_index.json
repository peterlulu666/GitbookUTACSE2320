{"./":{"url":"./","title":"Introduction","keywords":"","body":"CSE 2320 Algorithms and Data Structures Introduction to Algorithms 3rd Edition "},"Notation convent introduction.html":{"url":"Notation convent introduction.html","title":"Notation conventions","keywords":"","body":"Notation convent introduction "},"Time Complexity for Loops.html":{"url":"Time Complexity for Loops.html","title":"Time Complexity of for Loops","keywords":"","body":"Time Complexity of for Loops Conventions Time complexity Time complexity for multiple variables Conventions 1.The time complexity of this code would be 5 + 5 + 5 = 3×53 \\times 53×5 = 15 #include int main() { for (int i = 0; i The output would be A: BBBB A: BBBB A: BBBB The time complexity of this code would be \\[ \\underbrace{N+⋯+N}_{M\\text{ times}} = M \\times N \\] for (int i = 0; i The output would be A: BBBB...BBBB A: BBBB...BBBB A: BBBB...BBBB .............. A: BBBB...BBBB [info] Time complexity We would use Θ\\ThetaΘ to indicate the time complexity of the code. The time complexity of this code is Θ(N×M)\\Theta (N \\times M)Θ(N×M) When the rows M and columns N are equal the time complexity would be Θ(N2)\\Theta (N^2)Θ(N​2​​) 2.The time complexity of this code would be 5 + 4 + 3 + 2 + 1 = (5+1)×52(5 + 1) \\times 5 \\over 2​2​​(5+1)×5​​ = 15 for (int i = 0; i The output would be A: BBBBB A: BBBB A: BBB A: BB A: B The time complexity of this code would be N+(N−1)+⋯+1N + (N - 1) + \\cdots + 1N+(N−1)+⋯+1 = (N+1)×N2(N + 1) \\times N \\over 2​2​​(N+1)×N​​ = (N2+N)2(N^2 + N) \\over 2​2​​(N​2​​+N)​​ for (int i = 0; i The output would be A: B......B ...... A: B [info] Time complexity The time complexity of this code is Θ(N2)\\Theta (N^2)Θ(N​2​​) 3.The time complexity of this code would be 1 + 2 + 3 + 4 + 5 = (1+5)×52(1 + 5) \\times 5 \\over 2​2​​(1+5)×5​​ = 15 for (int i = 1; i The output would be A: B A: BB A: BBB A: BBBB A: BBBBB The time complexity of this code would be 1+2+⋯+(N−1)+N1 + 2 + \\cdots + (N - 1) + N1+2+⋯+(N−1)+N = (1+N)×N2\\frac{(1 + N) \\times N}{2}​2​​(1+N)×N​​ = (N+N2)2(N + N^2) \\over 2​2​​(N+N​2​​)​​ for (int i = 1; i The output would be A: B ...... A: B......B [info] Time complexity The time complexity of this code is Θ(N2)\\Theta (N^2)Θ(N​2​​) 4.There are four power of 2 smaller than or equal to 10. They are 202^02​0​​, 212^12​1​​, 222^22​2​​, 232^32​3​​. Let's say that 23⩽10⩽2(3+1)2^3 \\leqslant 10 \\leqslant 2^{(3 + 1)}2​3​​⩽10⩽2​(3+1)​​. We would symply assume that 10=2(3+1)10 = 2^{(3 + 1)}10=2​(3+1)​​ and log210=(3+1)log_2 10 = (3 + 1)log​2​​10=(3+1). The time complexity of this code would be log210+log210+⋯+log210=log_2 10 + log_2 10 + \\cdots + log_2 10 = log​2​​10+log​2​​10+⋯+log​2​​10= 3+3+⋯+3=3 + 3 + \\cdots + 3 = 3+3+⋯+3= (3+1)+(3+1)+⋯+(3+1)=(3 + 1) + (3 + 1) + \\cdots + (3 + 1) = (3+1)+(3+1)+⋯+(3+1)=  10×4=\\ 10 \\times 4 =  10×4= 404040. for (int i = 1; i The output would be A1: B 1 B 2 B 4 B 8 A2: B 1 B 2 B 4 B 8 A3: B 1 B 2 B 4 B 8 A4: B 1 B 2 B 4 B 8 A5: B 1 B 2 B 4 B 8 A6: B 1 B 2 B 4 B 8 A7: B 1 B 2 B 4 B 8 A8: B 1 B 2 B 4 B 8 A9: B 1 B 2 B 4 B 8 A10: B 1 B 2 B 4 B 8 There are p power of 2 smaller than or equal to N. They are 202^02​0​​, 212^12​1​​, 222^22​2​​, 232^32​3​​, ⋯⋯ 2p−12^{p - 1}2​p−1​​. Let's say that 2(p−1)⩽N⩽2p2^{(p - 1)} \\leqslant N \\leqslant 2^p2​(p−1)​​⩽N⩽2​p​​. We would symply assume that N=2pN = 2^pN=2​p​​ and log2N=plog_2 N = plog​2​​N=p. The time complexity of this code would be log2N+log2N+⋯+log2N=log_2 N + log_2 N + \\cdots + log_2 N = log​2​​N+log​2​​N+⋯+log​2​​N= p+p+⋯+p=p + p + \\cdots + p = p+p+⋯+p= N×p=N \\times p = N×p=  N×log2N=\\ N \\times log_2 N =  N×log​2​​N= Nlog2NN log_2 NNlog​2​​N for (int i = 1; i The output would be A1: B 1 ...... B 2^(p - 1) .................. AN: B 1 ...... B 2^(p - 1) [info] Time complexity The time complexity of this code is Θ(NlogN)\\Theta (N log N)Θ(NlogN) 5.The time complexity of this code would be ∑i=110log2i \\sum_{i=1}^{10} log_2 i ​i=1​∑​10​​log​2​​i for (int i = 1; i The output would be i: 1 j takes values: 1 Iterations of for j for this i: 1 i: 2 j takes values: 1 2 Iterations of for j for this i: 2 i: 3 j takes values: 1 2 Iterations of for j for this i: 2 i: 4 j takes values: 1 2 4 Iterations of for j for this i: 3 i: 5 j takes values: 1 2 4 Iterations of for j for this i: 3 i: 6 j takes values: 1 2 4 Iterations of for j for this i: 3 i: 7 j takes values: 1 2 4 Iterations of for j for this i: 3 i: 8 j takes values: 1 2 4 8 Iterations of for j for this i: 4 i: 9 j takes values: 1 2 4 8 Iterations of for j for this i: 4 i: 10 j takes values: 1 2 4 8 Iterations of for j for this i: 4 The time complexity of this code would be ∑i=1Nlog2N \\sum_{i=1}^{N} log_2 N ​i=1​∑​N​​log​2​​N for (int i = 1; i The output would be i: 1 j takes values: 1 Iterations of for j for this i: 1 i: 2 j takes values: 1 2 Iterations of for j for this i: 2 i: 3 j takes values: 1 2 Iterations of for j for this i: 2 i: 4 j takes values: 1 2 4 Iterations of for j for this i: 3 ...... i: i j takes values: 1 2 4 8 16 2^p Iterations of for j for this i: log i ...... i: N - 1 j takes values: 1 2 4 8 16 2^p Iterations of for j for this i: log (N - 1) i: N j takes values: 1 2 4 8 16 2^p Iterations of for j for this i: log N [info] Time complexity The time complexity of this code is Θ(NlogN)\\Theta (N log N)Θ(NlogN). Time complexity The inner loop j value does not depend on outer loop i value, so it is the same for every iteration of the outer loop. for (int i = 1; i [info] Time complexity The time complexity of this code is Θ(NlogN)\\Theta (N log N)Θ(NlogN). for (int i = 1; i [info] Time complexity The time complexity of this code is Θ(NlogN)\\Theta (N log N)Θ(NlogN). for (int i = 1; i = 1; j = j / 2) { printf(\"B %d \", j); } } [info] Time complexity The time complexity of this code is Θ(NlogN)\\Theta (N log N)Θ(NlogN). for (int i = 1; i [info] Time complexity The time complexity of this code is Θ(N2)\\Theta (N^2)Θ(N​2​​). Time complexity for multiple variables for (int i = 1; i [info] Time complexity The time complexity of this code is Θ(n+pr)\\Theta (n + pr)Θ(n+pr). "},"Sorting Algorithms and Binary Search.html":{"url":"Sorting Algorithms and Binary Search.html","title":"Sorting Algorithms and Binary Search","keywords":"","body":"Sorting Algorithms and Binary Search Stable sorting Selection sort Stable sorting It does not change the relative order of items whose keys are equal. A sorting algorithm is stable iff, after it sorts an array, any two records that compare equal, will still be in the same relative order as they were before sorting. .tg {border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;} .tg .tg-baqh{text-align:center;vertical-align:top} .tg .tg-nrix{text-align:center;vertical-align:middle} Sort based on Tom before Jane and Bob before Anna 4 3 4 3 1 Bob Tom Anna Jane Henry .tg {border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;} .tg .tg-baqh{text-align:center;vertical-align:top} .tg .tg-nrix{text-align:center;vertical-align:middle} Stable sort Tom before Jane and Bob before Anna 1 3 3 4 4 Henry Tom Jane Bob Anna .tg {border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:0px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;} .tg .tg-baqh{text-align:center;vertical-align:top} .tg .tg-nrix{text-align:center;vertical-align:middle} Unstable sort Anna is now before Bob 1 3 3 4 4 Henry Tom Jane Anna Bob Selection sort find the first minimum element and store the element at array[0]. find the second minimum element and store the element at array[1]. find the i th minimum element and store the element at array[i - 1]. // C program for implementation of selection sort #include void swap(int *xp, int *yp) { int temp = *xp; *xp = *yp; *yp = temp; } void selectionSort(int arr[], int n) { int i, j, min_idx; // One by one move boundary of unsorted subarray for (i = 0; i Youtube selection sort algorithm Let's say that we have an array 2 7 4 1 5 3 index 0 index 1 index 2 index 3 index 4 index 5 We need to look for the minimum number, which is 1. We swap the value of index 0 and index 3. 1 7 4 2 5 3 index 0 index 1 index 2 index 3 index 4 index 5 We would also look for the next minimum number, which is 2. We swap the value of index 3 and index 1. We would continue to do this until all the numbers are sorted. 1 2 3 4 5 7 index 0 index 1 index 2 index 3 index 4 index 5 "}}